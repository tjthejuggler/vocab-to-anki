#include<iostream>
#include<stdlib.h>
#include<cstdlib>
#include<time.h>
#include<cmath>
#include <iomanip>
#include <fstream>
#include<ctime>
#define SIZE 50
#define FILTERSIZE 100
void gauss_filter(int& fsize, double kernel[FILTERSIZE][FILTERSIZE]);

using namespace std;
int main()
{
	int image_size, filter_size, white_pixel, black_pixel;
	int i, j;
	int M[SIZE][SIZE];
	float Y[SIZE][SIZE];
	float A[SIZE][SIZE];
	double kernel[FILTERSIZE][FILTERSIZE] = { 0 };
	float zero_matrix[SIZE][SIZE];
	int input_grid_size = 21;
	ifstream infile;
	ofstream outfile;
	infile.open("inputs.txt");

	if (!infile)
	{
		cout << "Cannot open the input file.";
		return 1;
	}

	outfile.open("output.txt");

	infile >> image_size;
	infile >> filter_size;
	infile >> white_pixel;
	infile >> black_pixel;
	outfile << "Processing data...." << endl;
	
	srand(time(NULL));
	for (i = 0; i < image_size; i++)
	{
		for (j = 0; j < image_size; j++)
		{
			M[i][j] = (black_pixel)+rand() % (white_pixel - black_pixel + 1);
		}
	}
	outfile << "input matrix" << endl;
	outfile << "----------------------------------------" << endl;
	for (i = 0; i < image_size; i++)
	{
		for (j = 0; j < image_size; j++)
		{
			outfile << M[i][j] << "\t";
		}
		outfile << endl;
	}
	outfile << "----------------------------------------" << endl;
	gauss_filter(filter_size, kernel);
	outfile << "Gaussian Filter" << endl;
	outfile << "----------------------------------------" << endl;
	for (i = 0; i < filter_size; i++)
	{
		for (j = 0; j < filter_size; j++)
		{
			outfile << fixed << showpoint << setprecision(4);
			outfile << setw(9) << right << kernel[i][j];
		}
		outfile << endl;
	}
	outfile << "--------------------------------------------------------" << endl;
	outfile << fixed << showpoint << setprecision(4);

	for (i = 0; i < input_grid_size; i++)
	{
		for (j = 0; j < input_grid_size; j++)
			zero_matrix[i][j] = 0.0;
	}
	int K;
	K = (input_grid_size / 2) - (image_size / 2);//we make Y matrix here
	for (i = 0; i < input_grid_size; i++) //this Y matrix has input matrix at the middle of it 
	{
		for (j = 0; j < input_grid_size; j++)
		{
			if ((j >= K && j < K + image_size) && (i >= K && i < K + image_size))
			{
				outfile << setw(9);
				Y[i][j] = static_cast<float>(M[i - K][j - K]);
			}
			else
			{
				outfile << setw(9);
				Y[i][j] = zero_matrix[i][j];

			}

		}

	}
	outfile << endl;
	int s = 0;
	int temp_K = K;
	while (s < filter_size / 2)//we make the mirror here
	{
		for (i = 0; i < input_grid_size; i++)//to expand up and down
		{
			for (j = 0; j < input_grid_size; j++)
			{
				if (i == temp_K && j >= temp_K && j < temp_K + image_size + 2*s)
				{
					if (K == temp_K)
					{
						A[i - 1][j] = Y[i][j];
						A[i][j] = Y[i][j];
					}
					else
					{
						A[i - 1][j] = A[i][j];
					}
					
				}
				else if (i == temp_K + image_size + 2*s && j >= temp_K && j < temp_K + image_size + 2*s)
				{
					if (K == temp_K)
						A[i][j] = Y[i - 1][j];
					else
						A[i][j]= A[i - 1][j];
				}
				else
				{
					if (K == temp_K)
						A[i][j] = Y[i][j];
				}
					
			}


		}
		for (i = 0; i < input_grid_size; i++)//to expand left and right
		{
			for (j = 0; j < input_grid_size; j++)
			{
				if (i >= temp_K - (s+1) && j == temp_K -  1 && i <= temp_K + image_size+2*s)
				{
					A[i][j] = A[i][j + 1];
				}
				else if (j == temp_K + image_size + 2 * s && i >= temp_K - (s + 1) && i <= temp_K + image_size + 2 * s)
				{
					A[i][j] = A[i][j - 1];
				}
			}
		}
		s++;
		temp_K = temp_K - 1;
	}//end of mirror


	outfile << "Input Grid:" << endl;
	outfile << "---------------------------------------------------------------------" << endl;
	for (i = 0; i < input_grid_size; i++)
	{
		for (j = 0; j < input_grid_size; j++)
		{
			outfile << setw(9);
			outfile << A[i][j];
		}
		outfile << endl;
	}
	float sum = 0;
	int a, b;
	int temp_i, temp_j;
	float temp_A[SIZE][SIZE];
	for (i = K; i < K + image_size; i++)//we make gauss filter calculations here
	{
		for (j = K; j < K + image_size; j++)
		{
			sum = 0;
			temp_i = i;
			temp_j = j;
			for (a = 0; a < filter_size; a++)
			{
				for (b = 0; b < filter_size; b++)
				{
					sum = sum + (A[temp_i - (filter_size / 2)][temp_j - (filter_size / 2)] * kernel[a][b]);
					temp_j += 1;
				}
				temp_i++;
				temp_j = temp_j - filter_size;
			}
			temp_A[i][j] = sum / (filter_size*filter_size);
		}

	}//end of the gauss filter....
	outfile << "Output Grid:" << endl;
	outfile << "---------------------------------------------------------------------" << endl;
	for (i = 0; i < input_grid_size; i++)
	{
		for (j = 0; j < input_grid_size; j++)
		{
			outfile << setw(9);
			if (i >= K && i < K + image_size && j >= K && j < K + image_size)
			{
				outfile << temp_A[i][j];
			}
			else
			{
				outfile << zero_matrix[i][j];
			}
		}
		outfile << endl;
	}
	outfile << "Output (Filtered) Image" << endl;
	outfile << "---------------------------------------------------------------------" << endl;
	for (i = K; i < K + image_size; i++)
	{
		for (j = K; j < K + image_size; j++)
		{
			outfile << setw(9);
			outfile << temp_A[i][j];
		}
		outfile << endl;
	}
	outfile << endl << endl;
	outfile.close();
	infile.close();
	system("pause");
	return 0;
}



void gauss_filter(int& fsize, double kernel[FILTERSIZE][FILTERSIZE])
{

	int d, i, j, f;
	double value;

	cout.setf(ios::fixed);
	cout.precision(4);


	f = fsize / 2;
	for (d = 0; d < f; d++)
	{
		value = 1.0 / pow((2 * (d + 1) + 1), 2);
		for (i = -(d + 1); i <= d + 1; i++)
		{
			for (j = -(d + 1); j <= d + 1; j++)
				kernel[f - i][f - j] = kernel[f - i][f - j] + value;
		}
	}

	for (i = 0; i < fsize; i++)
	{
		for (j = 0; j < fsize; j++)
		{
			kernel[i][j] = kernel[i][j] / static_cast<double>(fsize);
		}
	}